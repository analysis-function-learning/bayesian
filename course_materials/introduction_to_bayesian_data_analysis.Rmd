---
title: "Introduction To Bayesian Data Analysis"
author: "Hannah Hodge Waller"
output:
  html_document: 
    theme: united
    highlight: zenburn
    toc: yes
    toc_float: yes
    number_sections: true
---
<!-- Places the AF and DSC Logo above the table of contents -->
<!-- uses https://www.base64-image.de/ to convert image to base 64, if not image disapears if not in same folder as .png etc --> 
<!-- This is a very long string - recommend to hide it using > arrow in line 17 -->
<style>
#TOC {
  background: url('data:image/png;base64,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');
  background-size: contain;
  padding-top: 130px !important;
  background-repeat: no-repeat;
  border: 0 ;
}
</style>

# {.unnumbered .toc-ignore}

<!-- Above # is needed to hide TOC section -->
<!-- AF and DSC Banner with words with bars. Alternatively an image that relates to the course. -->

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("../images/AF_DSC_banner.png"),
               alt = 'AF and DSC logo')
```
<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 
<!--- Date course last updated and a contact for any help needed. --->
<center> Course Release: June 2021 | <a href="mailto:GSS.Capability@statistics.gov.uk=Help with course Bayesian Data Analysis">Need help? Contact the team.</a></center>

<!-- Set up Chunks for R and Python -->
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(reticulate)
use_python("C:/pymc_virtual/Scripts/python")
py_run_string("import os as os")
py_run_string("os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = 'C:/Users/hodgeh/Anaconda3/Library/plugins/platforms'") 

``` 


<!-- Fill out as appropriate for your course -->
# Course Outline

* Course Outline and Information - please read carefully.
* Packages and Data
* What is Bayesian Data Analysis
* Examples of Bayesian Analysis
* A refresher on Probability
* Bayes' Theorem
* The Monty Hall Problem
* Components of Bayesian Analysis
* Approximate Bayesian Computation
* Quadratic Approximation
* Markov Chain Monte Carlo (MCMC)
* Summarising Posterior Distributions
* Bayesian Linear Regression Models
* Summary
* References

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Learning Outcomes
By the end of this course you should have a basic knowledge of Bayesian Data Analysis and how it can be done in Python or R.

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Prerequisite Knowledge:

This course assumes that you have basic statistical and mathematical knowledge. No prior knowledge of Bayesian analysis is required. 

This course also assumes basic R and Python knowledge as demonstrated in the Introduction to R and Introduction to Python courses. This includes reading in data and data manipulation using tidyverse (R) and pandas (python).

Additional packages will need to be installed for these courses; it is assumed you will know how to install additional packages, including setting up your computer to do so if required (e.g ONS' Artifactory system, [instructions can be found at this link](http://np2rvlapxx507/BPI/coding-getting-started-guide/-/wikis/home)).

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

<!-- This also serves as a template for when you add tabsets in later. Just copy and paste these and alter -->

## Course Format:

This course is written in both the Python and the R programming language.

Where code is provided it will be presented in tabs; one for Python and one for R. Please choose the tab with the language you wish to use.

An example is below.

## Code Examples {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python}
print("This tab contains Python code")
```
 

### **R**  {.unnumbered .toc-ignore}
```{r warning=FALSE}
print("This tab contains R code")
```

## {.unlisted .unnumbered .toc-ignore}

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Duration

This course should take approximately 6 hours to complete.

<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 

# Packages and Data

## Packages {.tabset .tabset-fade }
### **Python Packages** {.unnumbered .toc-ignore}

We have found this course does not work with Python version 3.6 due to errors with pycm3; we recommend updating to more modern version of Python. This course is written using Python 3.8.3. - which is part of the current Anaconda installation within ONS.

```{python}
# Print Python Version
print(sys.version)
```
Package requirements:


Note:

Pymc3 is a tricky package to install. It is recommended that you work with a new virtual environment and install PyMC3 first; and then any other dependencies (in this case just statsmodels)

Advice on installation can be found on the pyMC3 Github for [Microsoft Windows](https://github.com/pymc-devs/pymc3/wiki/Installation-Guide-(Windows)) and [Mac OS](https://github.com/pymc-devs/pymc3/wiki/Installation-Guide-(MacOS)) - note that m2w64-toolchain is not available on ONS machines; this affects the speed of some samplers; but is not an essential part for this course.

**ONS**  Advice on virtual environments using Conda, Virtual Env and attaching these to a Jupyter Notebook can be found here [internal ONS guidance](http://np2rvlapxx507/BPI/coding-getting-started-guide/-/wikis/home)

**Other Departments** This online Guidance on using [virtualenv](https://realpython.com/python-virtual-environments-a-primer/) and [conda enviroments](https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html) may be useful.
This information about using [virtual enviroments in Jupyter Notebooks](https://janakiev.com/blog/jupyter-virtual-envs/) may also be useful.

* pymc3
* pandas
* numpy
* matplotlib.pyplot
* scipy.stats



```{python}
import pymc3 as pm
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import binom, norm, uniform, triang, gaussian_kde
import statsmodels.api as sm

#%matplotlib inline # Uncomment this line if you're using a Jupyter Notebook
```


```{python include=FALSE}
import matplotlib
import scipy
plt.rcParams.update({'figure.max_open_warning': 0})
#%matplotlib inline # Uncomment this line if you're using a Jupyter Notebook
```

This course has been written using the following package versions:

```{python}

print("pymc3 Version:", pm.__version__ )
print("Pandas Version:", pd.__version__ )
print("Numpy Version:", np.__version__ )
print("Matplotlib Version:", matplotlib.__version__ )
print("Scipy Version:", scipy.__version__ )
print("Statsmodels version:", sm.__version__)
```

### **R Packages** {.unnumbered .toc-ignore}

This course was written in R Version
```{r}
# Find R Version
version
```
And Uses the packages - 

* dplyr
* readxl
* ggplot2
* MCMCpack
* bayesplot
* HDInterval
* Tidybayes
* patchwork (for displaying plots side by side)

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(readr)
library(ggplot2)
library(MCMCpack)
library(bayesplot)
library(HDInterval)
library(tidybayes)
library(patchwork)
```

This course has been written using the following package versions:

```{r include=FALSE}
dplyr_v <- as.character(packageVersion("dplyr"))
readr_v <- as.character(packageVersion("readr"))
ggplot2_v <- as.character(packageVersion("ggplot2"))
mcmcpack_v <- as.character(packageVersion("MCMCpack"))
bayesplot_v <- as.character(packageVersion("bayesplot"))
hdinterval_v <- as.character(packageVersion("HDInterval"))
tidybayes_v <- as.character(packageVersion("tidybayes"))
patchwork_v <- as.character(packageVersion("patchwork"))
```


```{r}
cat("dplyr Version:", dplyr_v)
cat("readr Version:", readr_v)
cat("ggplot2 Version:", ggplot2_v)
cat("MCMCpack Version:", mcmcpack_v)
cat("Bayesplot Version:", bayesplot_v)
cat("HDInterval Version:", hdinterval_v)
cat("Tidybayes VersionL", tidybayes_v)
cat("Patchwork Version", patchwork_v)
```

## {.unlisted .unnumbered .toc-ignore}

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Data {.tabset .tabset-fade }
Both Python and R courses use the same data.

titanic - a dataframe containing 1309 rows and 14 columns with information about passengers on the Titanic ship. (Please note this is **not** the inbuilt `Titanic` dataframe in R)

criminals - a dataframe containing 3000 rows and 2 columns with information about finger length and height (both in cm) of male criminals recorded in the early 1900s.


### **Python Data** {.unnumbered .toc-ignore}

```{python}
titanic = pd.read_csv("../data/titanic.csv")
criminals = pd.read_csv("../data/criminals_1902.csv")
```

<!-- bodyfat = pd.read_csv("../data/bodyfat.csv") -->

### **R Data** {.unnumbered .toc-ignore}


```{r}
titanic <- readr::read_csv("../data/titanic.csv") # note the lower case variable; do not overwrite the built in Titanic dataframe.
criminals <- readr::read_csv("../data/criminals_1902.csv")
```

<!-- bodyfat <- readr::read_csv("../data/bodyfat.csv") -->

## {.unlisted .unnumbered .toc-ignore}

<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 


# What is Bayesian Data Analysis?

Named after Thomas Bayes (1702-1761) who wrote an article about what we would now term "Bayesian Inference" that was published posthumously. Bayesian analysis is a statistical paradigm that answers research questions about unknown parameters using probability statements.

> "Bayesian inference is no more than counting the number of ways things can happen, according to our assumptions. Things that can happen more ways are more plausible."
>
> \- Richard McElreath, _Statistical Rethinking_

Bayesian data analysis is a method for figuring out unknowns using three things:

* Data
* A generative model (a model that can simulate data)
* Priors: existing information or current knowledge.

When parameters are known data can be simulated; using Bayesian inference we can estimate parameters from data.

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("../images/beysian_diagram.png"),
               alt = 'A diagram showing the flow of beysian data', 
               align = "centre",
               width = 700)
```


## Bayesian Vs Frequentist

In the Bayesian approach the parameters that we are trying to estimate are treated as random variables; compared to fixed values in the frequentist approach. Random variables in Bayesian are governed by things like mean and variance and their distributions such as Binomial, Gaussian, Poisson etc.

Priors are prior belief about these parameters; the Bayesian approach can be thought of as treating probabilities as degrees of belief; rather than frequencies generated by an unknown process.


<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Advantages and Disadvantages of Bayesian Approaches

There's a lot of material out there about the advantages and disadvantages of Bayesian techniques that expands beyond the scope of this course.

The advantages of a Bayesian approach are that it is possible to incorporate prior observations and prior knowledge. It's also useful with complex models and for missing data and several layers of variability. Bayesian approaches can be used to make management decisions based on data; including unlikely scenarios.

Bayesian can be a computationally expensive technique, and there is considerations around "priors" (assumptions around our data), and that we may sometimes need to use weakly informative priors; and that experimentation with priors can sometimes influence results.

More reading can be found online; a few examples of sources are [from the UN's FAO](http://www.fao.org/3/Y1958E/y1958e07.htm) and this documentation for [SAS](https://documentation.sas.com/doc/en/pgmsascdc/9.4_3.3/statug/statug_introbayes_sect015.htm)

<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 

# Examples of Bayesian Analysis

There are several famous examples of using Bayesian statistics.

## Alan Turing {.unnumbered .unlisted}

Alan Turing used Bayesian methods while cracking the enigma code; the Enigma was a cryptographic (enciphering) machine used by the German military in WWII. The German navy changed part of the Enigma keys every other day, giving a small window to decipher the code. One of the important cryptanalytic attacks against the navy was called "Banburismus"; a sequential Bayesian procedure that anticipated sequential analysis. More detailed information can be found in this paper by [Leeds University](http://www.mathcomp.leeds.ac.uk/turing2012/Images/Turing_Statistics.pdf). To credit solving the Enigma code completely to Turing's team is a little erroneous; and credit must also be given to Polish mathematicians and the [Bomba cryptography](https://en.wikipedia.org/wiki/Bombe) too - however that's probably more detail than is needed for this course.

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("../images/enigma.png"),
               alt = 'How Beysian Analysis helped crack the enigma code', 
               align = "centre",
               width = 700)
```

<center> Image Sources: <br>
[Enigma Machine](https://polandin.com/38967258/original-enigma-to-be-purchased-by-museum-of-polish-history)  |  [Enigma Machine Wheels](https://www.cryptomuseum.com/crypto/enigma/m3m4.htm)  |   [ Enigma Machine Code](https://www.matematiksider.dk/enigma_eng.html) </center>

## Nate Silver {.unnumbered .unlisted}

Nate Silver is an American statistician who used Bayesian methods to forecast the wins of Barrack Obama in the United States presidential elections in 2008 and 2012 elections. Although his team (working for Silvers' website FiveThirtyEight) did *not* predict Donald Trump's win in 2016; they did project a much higher probability of Trump winning than other pollsters. Silver does not like the term "predict" instead referring to his work as "rendering forecasts based on 'conditional probability'.


## In medicine {.unnumbered .unlisted}

Bayesian approaches are commonly used with medical data. While there is substantial data collected at a population level, the amount of data on any individual may be limited. Appropriately quantifying uncertainty is crucial for making decisions, especially where the optimal decision is often driven by the probability of relatively rare events; such are rare diseases or extreme reactions to a drug. Many universities are creating specialist departments, such as Lancaster University's [Bayes4Health](https://www.lancaster.ac.uk/bayes-for-health/) to better understand how Bayesian techniques can be applied to the "big data" using Data Science techniques.


## ONS COVID-19 Infection Survey {.unnumbered .unlisted}

ONS uses a Bayesian model in the Coronavirus(COVID-19) Infection Survey to provide 95% credible intervals. Selected households take nasal and throat swabs; these are then analysed in laboratories. Participants are swabbed at least once, then encouraged to have repeat tests every week for the first 5 weeks then monthly for a period of 12 months. Some individuals may also have blood tests. More detail about the collection methodology can be found on the [COVID-19 Infection Survey: methods and further information web page](https://www.ons.gov.uk/peoplepopulationandcommunity/healthandsocialcare/conditionsanddiseases/methodologies/covid19infectionsurveypilotmethodsandfurtherinformation#test-sensitivity-and-specificity)

All of the estimates are subject to uncertainty as the sample is only part of a wider population. The credible interval gives an indication of the uncertainty of an estimate from the data analysis. 95% credible intervals are calculated so there is a 95% probability of the true value lying in the interval. A good comparison of Frequentist vs Bayesian confidence intervals can be found [in this blog](http://jakevdp.github.io/blog/2014/06/12/frequentism-and-bayesianism-3-confidence-credibility/#:~:text=When%20trying%20to%20estimate%20the,a%20credible%20region%20(CR).)

Bayesian analysis is also used to understand the impact of false-positive and false-negative tests. The prevalence for various different observed positivity rates can be calculates using different assumptions about the test sensitivity and specificity. The full methodology can be found at the following link ["Test Sensitivity and Specificity - COVID-19 Infection Survey: methods and further information](https://www.ons.gov.uk/peoplepopulationandcommunity/healthandsocialcare/conditionsanddiseases/methodologies/covid19infectionsurveypilotmethodsandfurtherinformation#test-sensitivity-and-specificity)

These are just a few examples of the use of Bayesian statistics - there's many more including A/B testing, robotics and machine learning.

<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 
# A Refresher On Probability
## General Probability

In this section we will have a brief refresher on probability. Probability is the chance of an event occurring; defined between never happening (0) and always happening (1).

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("../images/bad_maths_drawings_probability.png"),
               alt = 'A serious probability scale on the top followed by a Star Wars Hans Solo reference on the bottom', 
               align = "centre",
               width = 700)
```

<center>[Image Source: Math with bad drawings](https://mathwithbaddrawings.com/2015/09/23/what-does-probability-mean-in-your-profession/)</center>


Let's refresh our memory on the titanic data set.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 
### **Python** {.unnumbered .toc-ignore}

```{python}
print("The titanic DataFrame has", len(titanic), "rows")
print("With 2 unique variables in the 'sex' colunn:", titanic["sex"].unique())
print("There are no missing values in this column", titanic["sex"].isnull().sum() )
print("There are", (titanic["sex"] == "female").sum(), "values marked female and", (titanic["sex"] == "male").sum(), "values marked as male")
```
 

### **R** {.unnumbered .toc-ignore}
```{r warning=FALSE}
cat("The titanic DataFrame has", nrow(titanic), "rows")
cat("With 2 unique variables in the 'sex' colunn:", unique(titanic$sex) )
cat("There are no missing values in this column", sum(is.na(titanic$sex)) )
cat("There are", sum(titanic$sex == "female"), "values marked female and", sum(titanic$"sex" == "male"), "values marked as male")
```

## {.unlisted .unnumbered .toc-ignore}

Checking if the column contains one of our genders gives us a Boolean series, where the value is `True`/`TRUE` if female, and `False`/`FALSE` if it's not.

Going forward Boolean values will be referred to in the text using the python wording of `True/False` - R users should substitute `TRUE/FALSE`.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 
### **Python** {.unnumbered .toc-ignore}

```{python}
(titanic["sex"] == "female").head()
```


### **R** {.unnumbered .toc-ignore}
```{r}
head(titanic$sex == "female")
```

## {.unlisted .unnumbered .toc-ignore}

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Marginal Probability.

This allows us to sum to find the number of female passengers.

We can use the mean function to find the fraction of values that were `True` (female)

We can also calculate this manually by dividing the number of female passengers by the number of rows in the data.

$$\frac{female\ passengers}{number\ of\ titanic\ rows}$$

The passenger being female is our *random variable* and is discrete in this case (a variable like age could be continuous)

The number of rows is our *sample space*; the total of all possible outcomes (Male or Female)

Multiplying the fraction by 100 gives us the percentage; here rounded to 2 decimal places.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 
### **Python** {.unnumbered .toc-ignore}

```{python}
print("Total female passengers:", (titanic["sex"] == "female").sum() )
print("Fraction of female passengers:", (titanic["sex"] == "female").mean() )
print("Which can also be calculated by female passengers/total rows in titanic",
(titanic["sex"] == "female").sum()/ len(titanic) )
print("Which is", round( (titanic["sex"] == "female").mean() *100 , 3), "%")
```
 
Note for Python if a column has missing values we need to remove those first before calculating the probability.


```{python}
# Without removing missing values
(titanic["age"] <= 18).mean()
```

```{python}
# Remove missing values
age_no_missing = titanic["age"].dropna()
# Calculate the mean
(age_no_missing <= 18).mean()
```

This is because in Python when filtering for `<=18` values like 0 or 6 or 18 will return `True`; but values like 27, 80 *and* NaN will return as `False`. 


### **R** {.unnumbered .toc-ignore}
Note that potential missing values have been handled using `na.rm = TRUE` in our sum and mean.
```{r}
cat("Total female passengers:", sum(titanic$sex == "female", na.rm = TRUE) )
cat("Fraction of female passengers:", mean(titanic$sex == "female", na.rm = TRUE) )
cat("Which can also be calculated by female passengers/total rows in titanic", sum(titanic$sex == "female")/ nrow(titanic) )
cat("Which is", round(mean(titanic$sex == "female", na.rm = TRUE) *100 , 3), "%") 
```

## {.unlisted .unnumbered .toc-ignore}

So when selecting a random passenger from the data the probability they are female is around 35.60% and male is around 64.40%

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 
### **Python** {.unnumbered .toc-ignore}

```{python}
titanic.sample()
```
 

### **R** {.unnumbered .toc-ignore}
Note - The sample in the Python tab will probably be different to the one in the R Tab - no seed has been set for this sample.
```{r}
slice_sample(titanic)
```

## {.unlisted .unnumbered .toc-ignore}

## Exercise{.tabset .tabset-fade .unnumbered} 

### **Question** {.unnumbered .toc-ignore}

What is the probability of a passenger embarking in Queenstown?

N.B The ports are coded values. 

* S = Southampton (England)
* C = Cherbourg (France)
* Q = Queenstown (Ireland) now known as Cobh

### **Python Answer** {.unnumbered .toc-ignore}

```{python}
# Remove missing value from ports
ports_no_missing = titanic["embarked"].dropna()
(ports_no_missing == "Q").mean()
```

Approximately 9.4%

### **R Answer** {.unnumbered .toc-ignore}
```{r}
mean(titanic$embarked == "Q", na.rm = TRUE)
```

Approximately 9.4 %

## {.unlisted .unnumbered .toc-ignore}

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Joint Probability

### Probability of A and B

So far only one probability has been covered; but often the possibility of A **AND** B needs to be explored.

For example the probability of a passenger being female is around 0.356. We can call this event A. This can be written as $P(A)$ = 0.356

The probability of a passenger surviving (survived == 1 ) is around 0.381. We can call this event B. This can be written as $P(B)$ = 0.381

We can also calculate the probability that the passenger is female **and** survived, this is called conjunction or intersection.

This is achieved by multiplying together the probability of A and the probability of B.

This is represented as $P(A \cap B)$ and is around 0.135 or 13.6%. This is lower than the probability of being female; as not all female passengers survived.

This can also be written as $P(A \cap B) = P(A) \times P(B)$ if independent.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**{.unnumbered .toc-ignore}

```{python}
(titanic["sex"] == "female").mean() * (titanic["survived"] == 1).mean()
```

Conjunction is commutative, e.g $P(A \cap B)$ = $P(A) \times P(B)$  is the same as $P(B \cap A)$ = $P(B) \times P(A)$ 
```{python}
(titanic["survived"] == 1).mean() * (titanic["sex"] == "female").mean()
```


### **R**{.unnumbered .toc-ignore}
```{r}
mean(titanic$sex == "female", na.rm = TRUE) * mean(titanic$survived == 1, na.rm = TRUE)
```

Conjunction is commutative, e.g $P(A \cap B)$ = $P(A) \times P(B)$  is the same as $P(B \cap A)$ = $P(B) \times P(A)$ 

```{r}
mean(titanic$survived == 1, na.rm = TRUE) * mean(titanic$sex == "female", na.rm = TRUE)
```

## {.unlisted .unnumbered .toc-ignore}

<hr style="width:50%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.50"> 

### Probability of A or B

It's also possible to calculate the probability of event A or B occurring by adding $P(A)$ and $P(B)$ together.

As our events are not mutually exclusive (e.g passengers can be female and survive or female and not survive) we also need to subtract the $P(A \cap B)$ 

The probability of a passenger being female or surviving is approx 0.602 or 60.2%. This can be written as $P(A \cup B)$ = 0.602

This can also be written as 
$$P(A \cup B) =\ P(A) + P(B) - P(A \cap B)$$

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore}  

### **Python**{.unnumbered .unlisted .toc-ignore}

```{python}

prob_female = (titanic["sex"] == "female").mean()
prob_survived = (titanic["survived"] == 1).mean()
prob_female_and_survived = prob_female * prob_survived


prob_female_or_survived = (prob_female + prob_survived) - prob_female_and_survived
prob_female_or_survived

```

Again, this is commutative.

```{python}
prob_female_or_survived = (prob_survived + prob_female) - prob_female_and_survived
prob_female_or_survived
```
### **R**{.unnumbered .unlisted .toc-ignore}
```{r}

prob_female <- mean(titanic$sex == "female", na.rm = TRUE)
prob_survived <- mean(titanic$survived == 1, na.rm = TRUE)
prob_female_and_survived <- prob_female * prob_survived

prob_female_or_survived <- (prob_female + prob_survived) - prob_female_and_survived
prob_female_or_survived

```
Again this is commutative.

```{r}
prob_female_or_survived <- (prob_survived + prob_female) - prob_female_and_survived
prob_female_or_survived
```

## {.unlisted .unnumbered .toc-ignore}

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Conditional Probability

It's also important to be able to calculate probability based on a condition.

For example if a random female passenger is picked; what's the probability they survived.

A.K.A what is the probability that a passenger is survived, given that they are female?

We can find this by dividing the probability of A and B occurring by the probability of A occurring. Using notation this looks like this.
$$P(B|A) =  \frac{P(A\cap B)}{P(A)}$$

Alternatively using our example

$$Probaility\ of\ survived\ given\ female =  \frac{Probability\ female \ and \ survived}{Probability\ female}$$

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 
### **Python**{.unnumbered .unlisted .toc-ignore}

```{python}
probability_female = (titanic["sex"] == "female").mean()
probability_survived = (titanic["survived"] == 1).mean()
probability_female_survived = probability_survived * probability_female


prob_survived_given_f = probability_female_survived / probability_female

prob_survived_given_f
```


### **R**{.unnumbered .unlisted .toc-ignore}
```{r}
probability_female <- mean(titanic$sex == "female", na.rm = TRUE)
probability_survived <- mean(titanic$survived == 1, na.rm = TRUE)
probability_female_survived <- probability_survived * probability_female

prob_survived_given_f <- probability_female_survived / probability_female

prob_survived_given_f
```

## {.unlisted .unnumbered .toc-ignore}

This is **not** commutative;

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 
### **Python**{.unnumbered .toc-ignore}

```{python}
probability_female = (titanic["sex"] == "female").mean()
probability_survived = (titanic["survived"] == 1).mean()
probability_female_survived = probability_survived * probability_female


prob_f_given_survived = probability_female_survived / probability_survived

prob_f_given_survived
```

### **R**{.unnumbered .toc-ignore}
```{r}
probability_female <- mean(titanic$sex == "female")
probability_survived = mean(titanic$survived == 1)
probability_female_survived = probability_survived * probability_female

prob_survived_given_f <- probability_female_survived / probability_female

prob_survived_given_f
```

## {.unlisted .unnumbered .toc-ignore}

This is also known as Bayes' Theorem

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## The Law of Total Probability

In addition to the three theorems talked about above it's also important to know the law of total probability.

$$P(A) = P(B_1\ and\ A)\ +\ P(B_2\ and\ A)$$

Essentially the probability if A is the sum of two possibilities. Either $B_1$ and $A$ are true, or $B_2$ and $A$ are true. This applies if $B_1$ and $B_2$ are mutually exclusive (only one can be true) and collectively exhaustive (one must be true)

Let's return to the probability that a respondent survived.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python}
(titanic["survived"] == 1).mean()
```
 

### **R**  {.unnumbered .toc-ignore}
```{r}
mean(titanic$survived == 1, na.rm = TRUE)
```

## {.unlisted .unnumbered .toc-ignore}

Now let's check we get the same overall probability if we calculate male and female survivors independently.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python}
female_survived = (titanic["sex"] == "female").mean() * (titanic["survived"] == 1).mean()
male_survived = (titanic["sex"] == "male").mean() * (titanic["survived"] == 1).mean()

female_survived + male_survived

```
 

### **R**  {.unnumbered .toc-ignore}
```{r}
female_survived <- mean(titanic$sex == "female", na.rm = TRUE) * mean(titanic$survived == 1, na.rm = TRUE)
male_survived <- mean(titanic$sex == "male", na.rm = TRUE) * mean(titanic$survived == 1, na.rm = TRUE)

female_survived + male_survived
```

## {.unlisted .unnumbered .toc-ignore}

There are only two given values for the sex of the passenger in this dataset; they are mutually exclusive and collectively exhaustive.

The law of total probability could also be written as

$$P(A) = P(B_1)P(A|B_1)+P(B_2)P(A|B_2)$$

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

``` {python}
probability_male = (titanic["sex"] == "male").mean()
probability_female = (titanic["sex"] == "female").mean()
probability_survived = (titanic["survived"] == 1).mean()
probability_female_given_survived =  (probability_female * probability_survived) / probability_female
probability_male_given_survived =  (probability_male * probability_survived) / probability_male

(probability_male * probability_male_given_survived) + (probability_female * probability_female_given_survived)
#     P(B1)            P(A|B1)                       +     P(B2)                 P(A|B2)
```
 

### **R**  {.unnumbered .toc-ignore}
```{r}
probability_male <- mean(titanic$sex == "male", na.rm = TRUE)
probability_female <- mean(titanic$sex == "female", na.rm = TRUE)
probability_survived <- mean(titanic$survived == 1, na.rm = TRUE)
probability_female_given_survived <-  (probability_female * probability_survived) / probability_female
probability_male_given_survived <-  (probability_male * probability_survived) / probability_male

(probability_male * probability_male_given_survived) + (probability_female * probability_female_given_survived)
#     P(B1)            P(A|B1)                       +     P(B2)                 P(A|B2)
```

## {.unlisted .unnumbered .toc-ignore}


As you can see this is the same output.

For more than two conditions writing the law of total probability as a summation is more concise

$$P(A) = \sum\limits_{i}P(B_i)P(A|B_i)$$

Which remains true as long as the conditions $B_i$ are mutually exclusive and collectively exhaustive.

<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 

# Bayes' Theorem

Bayes' theorem is a principled way of calculating a conditional probability without the joint probability. We often don't have access to the denominator (e.g $P(B)$) directly; and it can be calculated in an alternative way such as:

$$P(B) = P(B|A) + P(B|not A)\ \times\ P(not A)$$

Which gives the formulation of Bayes' Theorem that can be used to generate the alternate calculation of $P(B)$:

$$ P(A|B) = \frac{P(B|A)\times P(A)}{P(A) + P(B|not A) * P(not A)}$$

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Example of Bayes Theorem

A classic example is an urn problem.

Two identical urns exist. Urn 1 contains 30 red marbles and 10 blue marbles. Urn 2 contains 20 red marbles and 20 blue marbles.

If one urn is chosen at random and 1 marble (selected without looking) chosen from that bowl. If the marble is red what is the probability that it came from urn 1?

This can be written as $P(U_1|R)$ or $P(urn\ one\ given \ red\ marble)$

From the statement we know

* The conditional probability of getting a red marble if we choose from bowl 1 $P(R|U_1)$
* The conditional probability of getting a red marble if we choose from bowl 2 $P(R|U_2)$

Bayes' theorem shows the link

$$P(V_1|R) = \frac{p(V_1)P(R|V_1)}{P(R)}$$

$$P(V_1|R) = \frac{0.5 * 0.75}{0.625}$$

$$P(V_1|R) = \frac{0.375}{0.625}$$

$$P(V_1|R) = 0.6$$

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Diachronic Bayes

Bayes' rule is a recipe for turning around a conditional probability to learn about the thing we're interested in. It's possible to update the probability of a hypothesis (H) given some data (D) - the theorem can be re-written as:

$$P(H|D) = \frac{P(H) P(D|H)}{P(D)}$$

When written like this:

* $P(H)$ is the probability of the hypothesis before we consider the data - called the prior probability, often referred to as just **prior**.
* $P(H|D)$ is the probability of the hypothesis given the data; and is called the posterior.
* $P(D|H)$ is the probability of the data under the hypothesis and is called the likelihood.
* $P(D)$ is the total probability of the data under any hypothesis


Probability of having Zombie Virus is $P(Infected)$ = 0.000001

The Zombie test has no false negatives $P(Test Positive|Infected)$ = 1

But there are some false positives $P(Test Positive|Uninfected)$ = 0.001

Applying that into Bayes' Rule

$$P(Infected|Test\ Positive) = \frac{P(Infected) P(Test\ Positive|Infected)}{P(Test\ Positive)}$$

The missing value of the $P(Test\ Positive)$ can be found by working out:

$$P(Test\ Positive)$ = P(Test\ Positive\ \cap\ Infected) + P(Test\ Positive\ \cap\ Uninfected)$$ 

Or to break it down further:

$$P(Test\ Positive) = P(Test\ Positive\ |\ Infected) * P(Infected) + P(Test\ Positive\ |\ Uninfected) * P(Uninfected)$$

To work out the probability of being uninfected we know $P(Uninfected) = 1 - P(Infected)$

So the previous statement can be re-arranged as 

$$P(Test\ Positive\ |\ Infected) * P(Infected) + P(Test\ Positive\ |\ Uninfected) * (1- P(Infected))$$

$$P(Test\ Positive)$ = ( ( 1 * 0.000001 ) + 0.001 ) * (1 - 0.000001)$$

$$P(Test\ Positive) = 0.01000099$$

Returning to the Bayes' Rule, all of the elements can now be plugged in; as a reminder:

Probability of having Zombie Virus is $P(Infected)$ = 0.000001
The Zombie test has no false negatives $P(Test Positive|Infected)$ = 1
But there are some false positives $P(Test Positive|Uninfected)$ = 0.001
The probability of testing positive is $P(Positive)$ = 0.01

$$P(Infected|Test\ Positive) = \frac{P(Infected) P(Test\ Positive|Infected)}{P(Test\ Positive)}$$

$$P(Infected|Test\ Positive) = \frac{ 0.000001  * 1  }{0.01}$$

$$P(Infected|Test\ Positive) = 0.0001$$ 

Even though false positives are unlikely - the chance of being infected given a positive test is 1 in 10,000.

<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 

# The Monty Hall Problem

"Let's make a Deal" was an American TV show, starting in 1963 and was created and produced by Stefan Hatos and Monty Hall. Monty Hall served as the host for nearly 30 years.

The final game of each episode presented the winner with 3 doors (A, B and C). One door has the grand prize (such as a car) and the other two doors have lesser prizes. In the "Monty Hall Problem", a probability puzzle loosely based on the game show the prizes are usually represented by a sports car with goats behind the other doors.

The contestant knows that there are 2 goats and 1 car but does not know what is behind which door. The host (Monty) knows what is behind each door.

The contestant chooses door A; before opening door A Monty opens door B revealing a Goat.

He now asks if the contestant would like to switch doors. Should the contestant switch doors?

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("../images/monty_hall.png"),
               alt = 'XKCD Comic - Monty Hall', 
               align = "center",
               width = 700)
```
<center> Image Sources: <br>
[XKCD - Monty Hall](https://xkcd.com/1282/)</center>
 
It is natural to think that it doesn't matter; with two doors remaining the odds of winning the car is obviously 50/50. However this is an incorrect assumption and using Bayes Theorem the actual odds of winning the car if sticking with door A **or** switching to door B can be calculated.

In this segment some of the terminology will be introduced such as "Posteriors", "Priors" and "Likelihood" - these are explained in more detail in the next segment called "Components of Bayesian Models".

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Posteriors

If the contestant picks door A and Monty opens Door B. Monty will never open a door showing the car; so wouldn't open door C if the car was behind it so we only need to calculate two posteriors.

1. $P(Door\ A|Opens\ B)$ The probability that A is correct if Monty opens B
2. $P(Door\ C|Opens\ B)$ The probability that C is correct if Monty opens B

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Priors

The probability of any door being correct before a door is chosen is 1/3. Prizes are randomly arranged and we have no other information so the prior $P(A)$ of any door being correct is 1/3.

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Likelihood

If the car is actually behind door A Monty is free to open either B or C so the probability of opening either is 1/2 (50%)

If the car is behind door C then Monty can only open door B. Monty can't open door A as the contestant selected it; and can't open door C as that has the car behind it.

$P(Opens\ B| Door\ A)$ is 0.5

$P(Opens\ B| Door\ C)$ is 1.0

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Completing the formula

$$P(A|B) = \frac{P(B|A) \times  P(A)} {P(B)}$$

**Numerator**

$P(Opens\ B|Door\ A) \times P(A)$ is 1/2 x 1/3 = 1/6

$P(Opens\ B|Door\ C) \times P(A)$ is 1/3 x 1 = 1/3

**Normalising Constant: P(B) **

As our analysed events cover all possible options and do not overlap the sum of the numerators can be used.

$P(B)$ = 1/6 + 1/3 

$P(B)$ = 1/2

With these we can complete our formula.

$P(Door\ A| Opens\ B)$ = $\frac{1/6}{1/2}$ 

$P(Door\ A| Opens\ B)$ = 1/3

$P(Door\ C| Opens\ B)$ = $\frac{1/3}{1/2}$

$P(Door\ C| Opens\ B)$ = 2/3

**There is a higher probability of winning if the contestant changes doors after Monty has opened a door.**

<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 

# Components of Bayesian Models

In this section the components of a Bayesian Model will be explored in more detail.

To illustrate these an example of estimating global surface water will be used. To estimate how much of the earth's surface is covered in water an experiment is designed. A hand held globe is tossed in to the air, and when caught the presence of either land (L) or water (W) under the right index finger is recorded.

This experiment is repeated to generate the data; a sequence of observations.

`"W", "L", "W", "W", "W", "L", "W", "L", "W"`

McElreath **(Statistical Rethinking 2.2)** suggests that simple Bayesian Model Design benefits from three steps:

* *Data Story* - Motivate the model by narrating how the data may arise
  * Describe aspects of the underlying reality and the sampling process
  * Translate this description into a formal probability model
  * Acts as a framework for interpretation; but is still a story
  * Helps to highlight additional questions that must be answered (hypotheses are frequently vague)
  
* *Update* - Educate the model by feeding it data
  * Bayesian models begin with a set of plausibilities assigned to each possibility (the Prior)
  * Update those plausibilities based on the data to give **posterior** plausibility

* *Evaluate* - Is the model accurate or does it need to be changed.
  * Certainty is no guarantee that the model is accurate or good
  * Models should be supervised and critiqued
  * Check the model's adequacy for the purpose or in light of new information.

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Data Story

A data story attempts to explain how the data came to be. This can be either a descriptive or a causal explanation. Descriptive accounts specify associations that can help predict outcomes of interest and causal accounts explain how a process produces a given pattern.

A data story should be sufficiently complete to be able to generate new data. This is achieved by trying to explain how each piece of data is created as a result of the underlying reality and the sampling process.

## Exercise {.tabset .tabset-fade .unnumbred} 
### **Question**{.unnumbered .toc-ignore}

What is the data story for the globe tossing example?
 

### **Answer**{.unnumbered .toc-ignore}

The data story is the sample process we stated earlier.
"A globe is tossed in to the air and on catching if the area under the right index finger is land, 'L' is recorded. If the area is water 'W' is recorded."

1. The true proportion of water covering the Earth is $p$
2. A single toss of the globe has the probability $p$ of producing water ('W') observations and a probability of 1-$p$ of producing land.
3. Each toss is an independent trial; previous tosses do not influence future ones.

## {.unlisted .unnumbered .toc-ignore}

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Baysian Updating

A Bayesian model begins with one set of plausibilities assigned to each possible result - these are the prior plausibilities. These values are updated in light of data to produce our posterior plausibilities - though a process called Bayesian Updating.

The data helps to determine the plausibility of each possible proportion. The model starts with the given plausibility (a prior) assigned to every possible proportion of water (from 0% to 100%) and then updates these in line with the data seen to derive the posterior prior.

Before the globe is thrown for the first time it could be assumed that every proportion of water had the same plausibility. The first data point is "W" and we use this information to update the plausibility of each possible proportion. The plausibility for a 0% coverage of water is now 0; as some water has been observed if is now effectively impossible to have a 0 proportion of water. As no land has been observed the plausibility of higher proportions of water than land increases. With more observations the plausibility of each value in $p$ is revised; when a "W" is observed this makes higher values of P more plausible, when an L is observed it makes lower values of P more plausible. 

In reality data is often presented to a computer all at once rather than the iterative process described above. 

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Evaluation

As the amount of data increases our model will become increasingly sure of the proportion of water. This happens even if the model is misleading because our estimates are conditional based on our model. Effectively given a specific model we can be sure that plausible values are within a narrow range.

For example a different model globe may have different results; is the globe used accurate or is there some loss in quality as it is scaled down?

> "There is no approach to inference that provides universal guarantees. No branch of applied mathematics has unfettered access to reality, because math is not discovered, like the proton. Instead it is invented, like the shovel"  
>
> \- Richard McElreath, _ibid._

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Likelihood

The likelihood function is a mathematical formula that calculates the plausibility of the data seen.

With the globe tossing example a binomial likelihood function could be used to derive a likelihood of the data occurring subject to different values of $p$. This works with binary data, such as success or failure and in the model we used Water or Land.

As a reminder our data was 

`"W", "L", "W", "W", "W", "L", "W", "L", "W"`

The binomial distribution is given as $B(n,p)$ where $n$ is the number of trials and $p$ is the probability of success.

From this we can derive the probability of seeing $k$ successes, by getting the probability mass function for a given value of $k$.

The likelihood of the proportion of water on Earth being 0.5, given 9 trials and 6 successes (e.g getting W 6 times from 9 tosses).

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 
### **Python**{.unnumbered .toc-ignore}

```{python}
binom.pmf(k=6, n=9, p=0.5)
```
 

### **R**{.unnumbered .toc-ignore}

```{r}
dbinom(x = 6, size = 9, prob = 0.5)
```

## {.unlisted .unnumbered .toc-ignore}

This value is the relative number of ways of getting six "W" values when you do nine trials and $p$ is equal to 0.5.

Changing $p$ gives a different likelihood.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 
### **Python**{.unnumbered .toc-ignore}

```{python}
binom.pmf(k=6, n=9, p=0.7)
```
 

### **R**{.unnumbered .toc-ignore}

```{r}
dbinom(x = 6, size = 9, prob = 0.7)
```

## {.unlisted .unnumbered .toc-ignore}

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 
### **Python**{.unnumbered .toc-ignore}

```{python}
binom.pmf(k=6,n=9,p=0.3)
```
 

### **R**{.unnumbered .toc-ignore}

```{r}
dbinom(x = 6, size = 9, prob = 0.3)
```

## {.unlisted .unnumbered .toc-ignore}

| P   | Ways       |
|:---:|:----------:|
| 0.3 | 0.02100395 |
| 0.5 | 0.1640625  |
| 0.7 | 0.26682793 |

There are not that many ways of getting 6 waters from 9 trials if $p$ is 0.3 so it's quite a bit less plausible a value for the Earth's surface than 0.5 or 0.7.


You may find it useful to read more about conuuancy and Beta Priors; there are several useful articles linked in the [Wikipedia Article on Conugate Prior](https://en.wikipedia.org/wiki/Conjugate_prior)

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Paramaters

Above we specified our parameters in terms of the binomial likelihood

* $p$ - The probability of success - e.g the probability of observing water
* $n$ - The number of trials, a.k.a the sample size
* $k$ - The number of successes, e.g the number of "W" values observed.

In the globe testing example both $n$ and $k$ are known data, leaving $p$ as our unknown. We want to know what the most plausible value of $p$ is given our data.

In other contexts it may be needed to estimate different parameters of our model; of it may have many more parameters than a simple binomial likelihood function.

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Priors

Every estimated parameter needs a prior. This is an initial assignment of plausibility for each possible value of a parameter.

Priors can be useful in constraining  parameters to reasonable ranges or expressing any knowledge we have about the likely value of the parameter before any data is captured. In the globe tossing example prior knowledge says it is extremely unlikely that the earth has 0% water ($p = 0$) or 100% water ($p = 1$), and that values nearer $p = 0.5$ are more plausible than the extremes.

As priors are assumptions it is reasonable to try different priors to test the sensitivity of the model.

<hr style="width:75%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.75"> 

## Posteriors

After the likelihood function, parameters and priors are known the Bayesian Model can be estimated. The resulting estimates are the relative plausibility of the different parameter values; conditional on the data seen. These are known as the **posterior distribution**


The posterior can be thought of as $$Posterior = \frac{Likelihood\ x\ Prior}{Total\ Likelihood}$$

Where $Total\ Likelihood$ standardises the posterior ensuring the area under the curve is 1.

<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1">

# Aproximate Bayesian Compuation

## Grid Aproximation

Grid approximation is often not a practical tool to use as it scales very poorly as the number of parameters increases; however it is useful to examine it as it requires an understanding of the nature of Bayesian updating. 

For problems like the globe toss example a grid approximation is reasonable as a single parameter is being estimated.

The stages of a grid approximation:

1. Define a range of values to look at (the grid)
2. Calculate the value of the prior at each parameter value of the grid
3. Compute the likelihood at each parameter value
4. Compute the unstandardised posterior at each parameter, by multiplying the prior by the likelihood
5. Standardise the posterior by diving each value by the sum of all unstandardised values.


## Define a Grid {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

The larger the number of points on the grid the higher the precision of the estimates. More points will give a finer grained posterior.

### **Python**  {.unnumbered .toc-ignore}

```{python}
# define a grid for the posterior
p_grid = np.linspace(start=0, stop=1, num=20)
p_grid
```
 

### **R**  {.unnumbered .toc-ignore}
```{r}
p_grid <- seq(from = 0, to = 1, length.out = 20 ) # define grid
p_grid
```


## {.unlisted .unnumbered .toc-ignore}

## Define the Prior {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

The prior is a constant value of 1.

### **Python**  {.unnumbered .toc-ignore}

```{python}
prior = np.repeat(1, repeats=20)
prior
```
 

### **R**  {.unnumbered .toc-ignore}
```{r}
prior <- rep(1, times = 20)
prior
```

## Calculate the Likelihood {.unlisted .unnumbered .toc-ignore}

The binomial function takes the grid values of p here rather than a single value like was used previously.

##  {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python}
likelihood = binom.pmf(k=6, n=9, p=p_grid)
likelihood
```
 

### **R**  {.unnumbered .toc-ignore}
```{r}
likelihood <- dbinom(x=6, size=9, prob=p_grid)
likelihood
```

## Calculate and standardise posterior {.unlisted .unnumbered .toc-ignore}

The posterior can then be calculated and then standardised so that it sums to 1.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python}
# Compute the posterior
unstandardised_posterior = likelihood * prior

# Standardise the posterior so that it sums to 1
posterior = unstandardised_posterior / np.sum(unstandardised_posterior)
posterior
```
 

### **R**  {.unnumbered .toc-ignore}
```{r}
# compute the posterior
unstandardise_posterior <- likelihood * prior

# Standardise the posterior so it sums to 1

posterior <- unstandardise_posterior / sum(unstandardise_posterior)
posterior

```

## {.unlisted .unnumbered .toc-ignore}

## Plot {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

Plotting the posterior distribution gives a better sense of what it looks like. More points in a grid will give a smoother approximation of the posterior distribution.

### **Python**  {.unnumbered .toc-ignore}


```{python eval =FALSE}
f, ax = plt.subplots(figsize=(6,4))
ax.plot(p_grid,posterior);
ax.set_xlabel('Proportion of water');
ax.set_ylabel('Posterior Probability');
##plt.show();
# Note - the absurd number of semi colons is to suppress output lines in the RMD used to create this document.
# One at the end is enough for "normal" running of the code!
```

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("python_chart_images/posterior_probability_a.png"),
               alt = 'Learning Academy, Analysis Function and Data Science Campus Logos', 
               align = "centre",
               width = 700)
```


### **R**  {.unnumbered .toc-ignore}
```{r}
# Converted to a tibble so GGplot can be used.
globe_toss <- tibble(p_grid, posterior)

ggplot2::ggplot(data = globe_toss, aes(x = p_grid, y = posterior ) ) +
  geom_line() +
  labs(x = "proportion of water", y = "Posterior Probability")
```

## {.unlisted .unnumbered .toc-ignore}


Running the experiment with a different prior changes the posterior. 

The previous prior was 1; If this is changed so any values in the `p_grid` < 0.5 have a new prior of 0 what happens to the posterior?

## Change Prior {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python}
prior2 = np.where(p_grid < 0.5, 0, 1)
prior2
```
 

### **R**  {.unnumbered .toc-ignore}
```{r}
prior2 = ifelse(p_grid < 0.5, 0, 1)
prior2
```

## {.unlisted .unnumbered .toc-ignore}


## Calculate posterior {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python}
# Compute the posterior
unstandardised_posterior2 = likelihood * prior2

# Standardise the posterior so that it sums to 1
posterior2 = unstandardised_posterior2 / np.sum(unstandardised_posterior2)
posterior2
```
 

### **R**  {.unnumbered .toc-ignore}
```{r}
# compute the posterior
unstandardise_posterior2 <- likelihood * prior2

# Standardise the posterior so it sums to 1

posterior2 <- unstandardise_posterior2 / sum(unstandardise_posterior2)
posterior2
```

## {.unlisted .unnumbered .toc-ignore}


## Plot {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore}

Plotting the posterior distribution gives a better sense of what it looks like. More points in a grid will give a smoother approximation of the posterior distribution.

### **Python**  {.unnumbered .toc-ignore}

```{python eval = FALSE}
f, ax = plt.subplots(figsize = (6,4))
ax.plot(p_grid,posterior2);
ax.set_xlabel('Proportion of water');
ax.set_ylabel('Posterior Probability');
plt.show();

# Note - the absurd number of semi colons is to suppress output lines in the RMD used to create this document
#One at the end is enough for "normal" running of the code!
```

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("python_chart_images/posterior_probability_b.png"),
               alt = 'Learning Academy, Analysis Function and Data Science Campus Logos', 
               align = "centre",
               width = 700)
```


### **R**  {.unnumbered .toc-ignore}
```{r}
# Converted to a tibble so GGplot can be used.
globe_toss2 <- tibble(p_grid, posterior2)

ggplot2::ggplot(data = globe_toss2, aes(x = p_grid, y = posterior2 ) ) +
  geom_line() +
  labs(x = "proportion of water", y = "Posterior Probability")

```

## {.unlisted .unnumbered .toc-ignore}

## Exercise {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Question**  {.unnumbered .toc-ignore}

You are given some data reporting the sex of first born children in families.
Male = 1, female = 0.

What is the probability of the 1st born child being male?

Use a grid approximation with 200 points.

Plot your results.

Python

```{python}
first_born = [0,1,0,1,0,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,0,0,1,1,
                1,0,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,1,1,1,
                1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,0,
                0,0,0,0,0,1,0,0,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,
                0,0,0,0]
```


R
```{r}
first_born <- c(0,1,0,1,0,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,0,0,1,1,
                1,0,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,1,1,1,
                1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,0,
                0,0,0,0,0,1,0,0,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,
                0,0,0,0)
```

### **Python Answer**  {.unnumbered .toc-ignore}

```{python eval = FALSE}
# Data

first_born = [0,1,0,1,0,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,0,0,1,1,
                1,0,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,1,1,1,
                1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,0,
                0,0,0,0,0,1,0,0,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,
                0,0,0,0]
                
# work out n (number of trails)
n = len(first_born)

# work out "successes" e.g 1 or "male" values.
k = first_born.count(1)


# Create the Grid
p_grid2 = np.linspace(start=0, stop=1, num=200)


# Define the prior as a constant value of 1 
prior = np.repeat(1, repeats=200)

# Calculate the Likelihood using the binomial function
likelihood = binom.pmf(k= k , n= n, p=p_grid2)

# Compute the posterior
unstandardised_posterior = likelihood * prior

# Standardise the posterior so that it sums to 1
posterior = unstandardised_posterior / np.sum(unstandardised_posterior)

# Plot
f, ax = plt.subplots(figsize=(6,4))
ax.plot(p_grid2,posterior);
ax.set_xlabel('Proportion of gender == "male"');
ax.set_ylabel('Posterior Probability');
#plt.show();

# Note - the absurd number of semi colons is to suppress output lines in the RMD used to create this document
#One at the end is enough for "normal" running of the code!
```
 
```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("python_chart_images/posterior_probability_exercise.png"),
               alt = 'Learning Academy, Analysis Function and Data Science Campus Logos', 
               align = "centre",
               width = 700)
```


### **R Answer**  {.unnumbered .toc-ignore}
```{r warning=FALSE}
first_born <- c(0,1,0,1,0,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,0,0,1,1,
                1,0,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,1,1,1,
                1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,0,
                0,0,0,0,0,1,0,0,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,
                0,0,0,0)


# work out n (number of trails)
n <- length(first_born)

# work out "successes" e.g 1 or "male" values.
successes <- length(first_born == 1)


# Create the Grid
p_grid2 <- seq(from = 0, to = 1, length.out = 20 ) # define grid

# Define the prior as a constant value of 1 
prior <- rep(1, times = 200)

# Calculate the Likelihood using the binomial function
likelihood <- dbinom(x= successes, size= n, prob=p_grid)

# Compute the Posterior
unstandardised_posterior <- likelihood * prior

# Standardise the posterior so that it sums to 1
posterior <- unstandardise_posterior / sum(unstandardise_posterior)

# Converted to a tibble so GGplot can be used.
first_born_tb <- tibble(p_grid2, posterior)

ggplot2::ggplot(data = first_born_tb, aes(x = p_grid2, y = posterior ) ) +
  geom_line() +
  labs(x = "Proportion of gender == 'male'", y = "Posterior Probability")


```

## {.unlisted .unnumbered .toc-ignore}


<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 	

# Quardratic Aproximation

As the globe tossing model has only one parameter estimating that value is quite simple - even on a grid of 100 or even 1000 points. However with even just 2 parameters to estimate this increases to $100^2$ or $1000^2$ points; this can become computationally expensive. Quadratic approximation may be a more useful alternative in this case. Quadratic Approximation is also known as Laplace Approximation.

Quadratic approximation makes a normal or 'Gaussian' approximation to the posterior. This is computationally lightweight as a normal distribution is able to be defined with a mean and a standard deviation.

In quadratic approximation

1. The mean is derived from finding the maximum a posteriori (the mode or "peak" of the posterior distribution)

2. The standard deviation is more complicated. In simple terms the optimiser that finds the maximum a posteriori uses a transformation called a Hessian to find the peak of the distribution. Mathematically the inverse of a Hessian gives us the covariance of a Gaussian distribution. 

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

<!-- Note - pymc3 does NOT like working in an RStudio Environment. This code has been run and tested within a Jupyter Notebook with packages of the same version as this RMD and it works fine.

Because of this an approach of "just fake it" has been done in the RMD

Reminder = eval = FASLE will show but not run, echo = false will show the output but not the code.
--> 


```{python, eval=FALSE}
globe_model = pm.Model()
# W L W W W L W L W
data = np.array([1,0,1,1,1,0,1,0,1])

# Specify the model
with globe_model:
    p = pm.Uniform('p', lower = 0, upper = 1) # prior
    k = pm.Binomial('k', n = len(data), p = p, observed = data.sum()) # likelihood

```

In this model the prior $p$ is specified as belonging to a uniform distribution with the range of 0 to 1. As $p$ is the only thing to be estimated this is the only prior. The other parameters are observed data.

The likelihood function is given by the Binomial distribution. 

* `n` is the number of trials in our data; found by getting the length of the trials.
* `p` is set to the prior variable defined earlier as there is no observations for this.
* `observed` is the number of 1's in our data, achieved by summing the data.

The model can now be used

```{python eval = FALSE}
mean = pm.find_MAP(model = globe_model)
mean['p']
```

```{python echo = FALSE}
print("array(0.66666667)")
```


The peak of the posterior distribution (the MAP estimate) is at 0.666. This can be used as the mean in the normal (quadratic) approximation of the full posterior distribution.

```{python eval = FALSE}
# standard deviation is the square root of the inverse of the Hessian.
std_dev = np.sqrt(1/(pm.find_hessian(mean, vars = [p], model = globe_model)[0]))
std_dev
```

```{python echo = FALSE}
print("array([0.15713484])")
```

The estimate of the standard deviation of $p$ is around 0.16. Using the mean and the standard deviation of $p$ allows the specification of a normal curve that approximates the posterior distribution of $p$, the proportion of the surface of Earth that is water.

```{python eval = FALSE}
f, ax = plt.subplots(figsize = (8,6))
x = np.linspace(0,1,100)
norm_pdf = norm.pdf(x, mean['p'], std_dev)
ax.plot(x, norm_pdf/sum(norm_pdf), label = "Quadratic Approximation")

# Grid Approximation on 100 gridpoints with flat (uniform) prior.
prior = np.repeat(1, 100)
likelihood = binom.pmf(6, 9, x)
# Compute the posterior
unstandardised_posterior = likelihood * prior
# Standardise the posterior so that it sums to 1
posterior = unstandardised_posterior/ np.sum(unstandardised_posterior)
ax.plot(x, posterior, label = 'Grid Approximation')
ax.legend()
ax.set_xlabel("Proportion of Water")
ax.set_ylabel('Probability')
plt.show();


```
<!--
```{python echo = FALSE}
norm_pdf = np.array([3.13319359e-04, 4.10708675e-04, 5.36149516e-04, 6.97016975e-04,
       9.02414752e-04, 1.16352150e-03, 1.49399118e-03, 1.91041205e-03,
       2.43282830e-03, 3.08532745e-03, 3.89669543e-03, 4.90113942e-03,
       6.13907651e-03, 7.65798356e-03, 9.51330034e-03, 1.17693745e-02,
       1.45004323e-02, 1.77915551e-02, 2.17396360e-02, 2.64542845e-02,
       3.20586453e-02, 3.86900871e-02, 4.65007164e-02, 5.56576639e-02,
       6.63430906e-02, 7.87538546e-02, 9.31007832e-02, 1.09607493e-01,
       1.28508705e-01, 1.50048012e-01, 1.74475054e-01, 2.02042079e-01,
       2.32999888e-01, 2.67593148e-01, 3.06055129e-01, 3.48601883e-01,
       3.95425971e-01, 4.46689811e-01, 5.02518781e-01, 5.62994230e-01,
       6.28146558e-01, 6.97948566e-01, 7.72309273e-01, 8.51068416e-01,
       9.33991864e-01, 1.02076814e+00, 1.11100629e+00, 1.20423521e+00,
       1.29990471e+00, 1.39738832e+00, 1.49598796e+00, 1.59494048e+00,
       1.69342613e+00, 1.79057876e+00, 1.88549765e+00, 1.97726080e+00,
       2.06493940e+00, 2.14761319e+00, 2.22438628e+00, 2.29440324e+00,
       2.35686486e+00, 2.41104331e+00, 2.45629619e+00, 2.49207928e+00,
       2.51795733e+00, 2.53361298e+00, 2.53885313e+00, 2.53361298e+00,
       2.51795734e+00, 2.49207928e+00, 2.45629620e+00, 2.41104331e+00,
       2.35686487e+00, 2.29440325e+00, 2.22438629e+00, 2.14761320e+00,
       2.06493941e+00, 1.97726081e+00, 1.88549766e+00, 1.79057877e+00,
       1.69342614e+00, 1.59494049e+00, 1.49598797e+00, 1.39738833e+00,
       1.29990472e+00, 1.20423521e+00, 1.11100629e+00, 1.02076815e+00,
       9.33991873e-01, 8.51068424e-01, 7.72309280e-01, 6.97948573e-01,
       6.28146564e-01, 5.62994236e-01, 5.02518787e-01, 4.46689817e-01,
       3.95425976e-01, 3.48601887e-01, 3.06055133e-01, 2.67593152e-01])

f, ax = plt.subplots(figsize = (8,6));
x = np.linspace(0,1,100);
ax.plot(x, norm_pdf/sum(norm_pdf), label = "Quadratic Approximation");
# Grid Approximation on 100 gridpoints with flat (uniform) prior.
prior = np.repeat(1, 100);
likelihood = binom.pmf(6, 9, x);
# Compute the posterior
unstandardised_posterior = likelihood * prior;
# Standardise the posterior so that it sums to 1
posterior = unstandardised_posterior/ np.sum(unstandardised_posterior);
ax.plot(x, posterior, label = 'Grid Approximation');
ax.legend();
ax.set_xlabel("Proportion of Water");
ax.set_ylabel('Probability');
plt.show();

# Note - the absurd number of semi colons is to suppress output lines in the RMD used to create this document
#One at the end is enough for "normal" running of the code!
```
-->

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("python_chart_images/posterior_grid_quad.png"),
               alt = 'Learning Academy, Analysis Function and Data Science Campus Logos', 
               align = "centre",
               width = 700)
```



There is a difference between the grid approximation and the quadratic approximation. This is because the quadratic approximation is not great with small numbers, like this instance. Given more data the quadratic will improve.

### **R**  {.unnumbered .toc-ignore}

```{r}
data <- c(1,0,1,1,1,0,1,0,1)

y <- sum(data == 1)
n <- length(data)

prior <- list(a = 1, b = 1)

posterior <- list(a = prior$a + y,  b = prior$b + n - y)

```

Here a function called `calc_posterior` has been created; which uses our priors and posteriors.

```{r}
calc_posterior <- function(par) {
  lprior <- dbeta(par, prior$a, prior$b, log = TRUE)
  lpost <- dbinom(y, size = n, prob = par, log = TRUE)
  - (lprior + lpost)
}

```

This is then applied using the optim function from the stats package; specifying a hessian.

```{r}
ret <- optim(0.5, fn = calc_posterior, hessian = TRUE, method = "Brent",
             lower = 0, upper = 1)
```

We can use this to find our MAP

``` {r}
map_max <- ret$par
map_max
```

The peak of the posterior distribution (the MAP estimate) or theta is at 0.666. This can be used as the mean in the normal (quadratic) approximation of the full posterior distribution.

```{r}
# standard deviation is the square root of the inverse of the Hessian.
std_dev <- sqrt(1/ret$hessian)
std_dev

theta_var <- 1 / drop(ret$hessian)
```

The estimate of the standard deviation of $p$ is around 0.16. Using the mean and the standard deviation of $p$ allows the specification of a normal curve that approximates the posterior distribution of $p$, the proportion of the surface of Earth that is water.

```{r}
tibble(
  theta = ppoints(100),
  approx = dnorm(theta, map_max, sqrt(theta_var)),
  actual = dbeta(theta, shape1 = posterior$a, shape2 = posterior$b)
) %>%
  ggplot2::ggplot(aes(x = theta)) +
  geom_line(aes(y = approx, color = "blue")) +
  geom_line(aes(y = actual, colour = "orange")) +
  scale_color_identity(name = "Key",
                          breaks = c("blue", "orange"),
                          labels = c("Quadratic Aproximation", "Grid Aproximation"),
                          guide = "legend")
  
```

There is a difference between the grid approximation and the quadratic approximation. This is because the quadratic approximation is not great with small numbers, like this instance. Given more data the quadratic will improve.


## {.unlisted .unnumbered .toc-ignore}

<hr style="width:50%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:0.5"> 

# Markov Chain Monte Carlo (MCMC)

As models get more complicated both the approximate grid and the quadratic approximation become insufficient. In this case techniques like Markov Chain Monte Carlo (MCMC) 

Unlike previous methods where the posterior distribution is calculated directly MCMC techniques draw a sample from the posterior; this gives a collection of parameter values where the frequencies of those values correspond with the posterior plausibilities.


## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

<!-- Note - pymc3 does NOT like working in an RStudio Environment. This code has been run and tested within a Jupyter Notebook with packages of the same version as this RMD and it works fine.

Because of this an approach of "just fake it" has been done in the RMD

Reminder = eval = FALsE will show but not run, echo = false will show the output but not the code.
--> 

```{python eval = FALSE}
posterior_sample = pm.sample(model = globe_model, random_seed=99)
```


### **R**  {.unnumbered .toc-ignore}
```{r}
posterior_sample <- MCMCpack::MCbinomialbeta(y = sum(data), n = length(data), beta = 1,  mc = 1000, seed = 99)
```

## {.unlisted .unnumbered .toc-ignore}

MCMC samplers can be complicated, however this is a simple task and the defaults are often sufficient. 

Pymc3 (python) computes 2 "chains" of 500 samples each, giving 1000 samples to work with.
MCMCpack (R) computes 1 "chain" so the sample has been set to 1000 to gain the same number of samples.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}


```{python eval = FALSE}
pm.traceplot(posterior_sample);
```

<!-- Note image of trace plot used here because again, pymc3 doesn't play nice with reticulate! -->
```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("../images/pymc_traceplot.png"),
               alt = 'Trace Plot', 
               align = "centre")
```

### **R**  {.unnumbered .toc-ignore}
```{r}
plot(posterior_sample)
```

More aesthetically pleasing trace and density plots can be created using the packages `coda` which is loaded as a dependency of `MCMCpack`

```{r}
coda::traceplot(posterior_sample)
```

```{r}
coda::densplot(posterior_sample)
```

Or using the package `bayesplot`

```{r}
bayesplot::mcmc_trace(posterior_sample)
```


```{r}
bayesplot::mcmc_dens(posterior_sample)
```

## {.unlisted .unnumbered .toc-ignore}

This diagram is called a "traceplot" and gives a sense of if the MCMC process is a good one based on how well mixed the samples are.

The sampler has created samples from the posterior distribution of $p$ that are very similar to the other methods calculated previously.

<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 	
# Summarising Posterior Distributions

We can get summary statistics of the posterior.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

Using MCMC allows us to look at some summary statistics of the posterior:

### **Python**  {.unnumbered .toc-ignore}

```{python eval = FALSE}
pm.summary(posterior_sample)
```
 
| .   |   mean |    sd |   hdi_3% |   hdi_97% |   mcse_mean |   mcse_sd |   ess_bulk |   ess_tail |   r_hat| |:----|-------:|------:|---------:|----------:|------------:|----------:|-----------:|-----------:|--------:|
| p  |  0.634 | 0.132 |    0.384 |     0.859 |       0.005 |     0.003 |        809 |       1215 |       1 |


| Summary      | Explanation                                      |
|--------------|--------------------------------------------------|
| mc_error     | The Montecarlo standard error for the trace, shows a sense of precision with which the mean can be estimated. For more information see [this link](https://rdrr.io/cran/LaplacesDemon/man/MCSE.html#:~:text=Monte%20Carlo%20Standard%20Error%20(MCSE,with%20the%20LaplacesDemon%20or%20LaplacesDemon)|
| hdi_3/97 | The highest density interval for even alpha values for the trace. The HPD is the minimum width Bayesian credible interval (or BCI). This is the interval within which a particular parameter values falls within a given probability|
| Rhat         | The Gelman-Rubin diagnostic test ($\hat{R}$) testing for convergence of the MCMC process. For more information see this [this link from Imperial](https://www.imperial.ac.uk/media/imperial-college/research-centres-and-groups/astrophysics/public/icic/data-analysis-workshop/2018/Convergence-Tests.pdf)|


### **R**  {.unnumbered .toc-ignore}

```{r}
summary(posterior_sample)
```

The HDI for 3% and 97% can be calculated too

```{r}
quantile(posterior_sample, c(0.03, 0.97))
```

## {.unlisted .unnumbered .toc-ignore}

Using the sample allows for a number of questions to be answered. A selection of common questions are:

* How much of the posterior probability lies below a given parameter value?
* How much of a posterior probability lies between the two parameter values?
* Which parameter value marks the lower 5% of the posterior distribution?
* Which range of parameter values contains 90% of the posterior probability?
* Which parameter value has the highest posterior probability?

## How much of a posterior probability is less than 0.5? {.unlisted .unnumbered .toc-ignore}

This can be used to calculate the posterior probability that surface water makes up less than 50% of the Earth's surface.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python eval= FALSE}
posterior_sample_array = posterior_sample.get_values(p)

(posterior_sample_array < 0.5).sum()/len(posterior_sample_array)
```
 
```{python echo = FALSE}
print(0.1665)
```

### **R**  {.unnumbered .toc-ignore}
```{r}
sum(posterior_sample <= 0.5) / length(posterior_sample)
```

## {.unlisted .unnumbered .toc-ignore}

This shows that approximately 17% of the posterior probability is below 0.5. This is the relative frequency of samples that meet our criteria (< 0.5) out of the total number of samples.

## How much of a posterior probability lies between 0.5 and 0.75? {.unlisted .unnumbered .toc-ignore}

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python eval = FALSE}
((posterior_sample_array > 0.5) & (posterior_sample_array < 0.75)).sum() / len(posterior_sample_array)
```

```{python echo = FALSE}
print(0.628)
```

### **R**  {.unnumbered .toc-ignore}
```{r}
sum((posterior_sample >= 0.5) & (posterior_sample <= 0.75)) / length(posterior_sample)
```

## {.unlisted .unnumbered .toc-ignore}

Approximately 62% of the posterior probability lies within a proportion of 0.5 and 0.75

## What is the value that covers the lower 80% of the posterior distribution? {.unlisted .unnumbered .toc-ignore}

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python eval = FALSE}
np.percentile(posterior_sample_array, 80)
```

```{python echo = FALSE}
print(0.7521118289192498)
```

### **R**  {.unnumbered .toc-ignore}
```{r}
quantile(posterior_sample, probs = 0.80)
```


## {.unlisted .unnumbered .toc-ignore}

80% of the samples in the posterior distribution lay below the value $p$ = 0.75

## What are the values that cover the middle 80% of the posterior distribution {.unlisted .unnumbered .toc-ignore}

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python eval = FALSE}
np.percentile(posterior_sample_array, [10, 90])
```

```{python echo = FALSE}
print("array([0.45732041, 0.80614929])")
```


The middle 80% is the range from the 10th to the 90th percentile. This relates to a posterior probability from around 0.45 to 0.80.

### **R**  {.unnumbered .toc-ignore}
```{r}
quantile(posterior_sample, probs = c(0.1,0.9))
```

The middle 80% is the range from the 10th to the 90th percentile. This relates to a posterior probability from around 0.44 to 0.81. The numbers for the Python and R calculation differ slightly; this is due to slight differences in the sampling under the hood between the two languages. 

## {.unlisted .unnumbered .toc-ignore}


## Highest Probability Density Interval {.unlisted .unnumbered .toc-ignore}

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python eval = FALSE}
pm.stats.hdi(posterior_sample_array)
```

```{python echo = FALSE}
print("array([0.3845, 0.859])")
```

The highest density interval is the minimum width Bayesian Credible Interval (BCI)

In this example that is between 0.38 and 0.85

### **R**  {.unnumbered .toc-ignore}
```{r}
HDInterval::hdi(posterior_sample)
```

The highest density interval is the minimum width Bayesian Credible Interval (BCI)

In this example that is between 0.38 and 0.91 ; again slightly different to the Python version due to differences in the model.

## {.unlisted .unnumbered .toc-ignore}

## Mean and Median Point Estimates {.unlisted .unnumbered .toc-ignore}

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python, eval = FALSE}
np.mean(posterior_sample_array)
np.median(posterior_sample_array)
```

```{python echo = FALSE}
print((0.63404908077911, 0.6381278200039779))
```

### **R**  {.unnumbered .toc-ignore}
```{r}
c(mean = mean(posterior_sample), median = median(posterior_sample))
```

## {.unlisted .unnumbered .toc-ignore}

## {.unlisted .unnumbered .toc-ignore}
<hr style="width:100%;height:4px;border-width:0;color:gray;background-color:#dd4814; opacity:1"> 

# Bayesian Linear Regression Models

This section will explore Bayesian inference in simple linear regressions.

This section uses the `criminals` data. In 1902 a social scientist called W.R Macdonell published a paper `On Criminal Anthropometry and the Identification of Criminals` which contained tables of physical characteristic of 3,000 non habitual male criminals, all over 21 who were serving sentences in England and Wales. Macdonell expressed an interest in if a limited number of anthropocentric measurements could be used to identify criminals. It's not clear from the paper if he believes these measurements can distinguish individual criminals or if that certain sets of measurements could identify criminality. 

This data contains

* Height in cm
* Length of left middle finger in cm

As with all new datasets - looking at the summary information can be helpful.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python}
criminals.head(5)
```

```{python}
criminals.describe()
```
 
### **R**  {.unnumbered .toc-ignore}

```{r}
head(criminals, n = 5)
```


```{r}
summary(criminals)
```

## {.unlisted .unnumbered .toc-ignore}

Visualising this data can also be beneficial.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python eval = FALSE}
f, (ax1, ax2, ax3) = plt.subplots(1,3, figsize = (16,5))

# Height
ax1.hist(criminals['height'], bins = 20, color = 'coral', alpha = 0.75);
xs = np.linspace(criminals['height'].min(), criminals['height'].max(),100);
norm_ys = norm.pdf(xs, loc = criminals['height'].mean(), scale = criminals['height'].std());
ax1.plot(xs, norm_ys, color = 'fuchsia', linewidth = 2);
ax1.set_title("Height of Criminals");
ax1.set_ylabel("Density");
ax1.set_xlabel('Height (cm)');


# Finger Length
ax2.hist(criminals['finger_length'], bins = 20, color = 'cadetblue', alpha = 0.75);
xs = np.linspace(criminals['finger_length'].min(),criminals['finger_length'].max(),100);
norm_ys = norm.pdf(xs, loc = criminals['finger_length'].mean(), scale = criminals['finger_length'].std());
ax2.plot(xs, norm_ys, color = 'lime', linewidth = 2);
ax2.set_title("Length of Left Middle Finger of Criminals");
ax2.set_ylabel("Density");
ax2.set_xlabel('length (cm)');

# Scatter
ax3.scatter(y = criminals['height'], x = criminals['finger_length'], marker='.', color = '0.45', alpha = 0.5 );
ax3.set_title("Relationship Between Criminal Height\n and Finger Length");
ax3.set_ylabel("Height (cm)");
ax3.set_xlabel("Length (cm)");
plt.show();
```

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("python_chart_images/height_finger_scatter.png"),
               alt = 'Learning Academy, Analysis Function and Data Science Campus Logos', 
               align = "centre")
```



### **R**  {.unnumbered .toc-ignore}
```{r}
plot_height <- ggplot2::ggplot(data = criminals) +
  geom_histogram(aes(x = height), bins = 20, fill = "coral", alpha = 0.75) +
  labs(title = "Height of Criminals")

plot_fingerlength <- ggplot2::ggplot(data = criminals) +
  geom_histogram(aes(x = finger_length), bins = 20, fill = "cadetblue", alpha = 0.75) +
  labs(title = "Length of Left Middle \n Finger of Criminals")

plot_scatter <- ggplot2::ggplot(data = criminals) +
  geom_point(aes(y = height, x = finger_length), alpha = 0.25) +
  labs(title = "Relationship Between \n Criminal Height\n and Finger Length")

plot_height + plot_fingerlength + plot_scatter  # This requires patchwork package to place plots side by side
```

## {.unlisted .unnumbered .toc-ignore}

## Model Description.

* Outcome Variables - The data that we want to predict or explain with the model
* Outcome likelihood - The likelihood function that defines the plausibility of individual observations in the outcome data. (For linear regression this is always the normal(Gaussian) distribution)
* Explanatory Variables - The remaining data that we want to model to predict or explain the outcome
* Relationship Likelihood to Predictors - The explanatory variables are related to the outcome likelihood parameters
* Priors Specified - All parameters for the model have a prior set to explain the initial state of the model before seeing the data.

In mathematical notation this is:

$$ 
\begin{aligned}
outcome_i \sim Normal(\mu_i, \sigma) \\
\mu_i = \alpha + \beta \times explanatory_i \\
\alpha \sim Normal(0,1) \\
\beta \sim Normal(0,1) \\
\sigma \sim Uniform(0,1)
\end{aligned}
$$
The first line is the likelihood function for the outcome we are interested in. As this is a linear regression the assumption is the outcome is the realisation of a normal distribution with given mean ($\mu$) and standard deviation ($\sigma$).

The tilde ($/sim$) specifies that the outcome (prior) is random (stochastic). ALthough the prior is mapped to a distribution no single outcome can be known with any certainty. Instead the distribution identifies the different plausibility of values for the outcome or prior. 

The second line is the linear model = $\sigma + \beta \times explanatory_i $. Note that this is specifying the values for $\mu_i$, effectively the mean value of $outcome_i$ subject to the linear model. Because this is a deterministic relationship note the $=$ instead of the $\sim$. Also $\mu_i$ is no longer a prior but constructed from the other parameters. If $\alpha$, $beta$ and $explanatory_i$ are known the mean for $outcome_i$ can be determined.

The linear model ($\alpha + \beta \times explanatory_i$) has two parameters to estimate and this the the equivalent of a conventional linear model.

* $\alpha$ - The expected (mean) value of the outcome when the explanatory variable is equal to 0. This is the intercept.
* $\beta$ - What is the change in the expected (mean) value of the outcome subject to a 1 unit change in the explanatory value. This is the slope or gradient.

This gives 3 priors to deal with; the model parameters $\alpha$ and $\beta$ and the standard deviation of outcome $\sigma$. Without any additional information a normal prior for $\alpha$ and $\beta$ with a reasonable mean for the data in question and an arbitrarily large standard deviation to allow the model some freedom in providing a good solution. The prior for $\sigma$ should always be > 0 as a negative standard deviation isn't possible. A wide uniform prior starting at zero is a weak prior that allows the model some flexibility.


## Applying the Model

The model specification for a Bayesian Linear Regression Model to predict criminal height as a linear function of finger length looks like this:

$$ 
\begin{aligned}
height \sim Normal(\mu_i, \sigma) \\
\mu_i = \alpha + \beta \times finger\ length_i \\
\alpha \sim Normal(166,100) \\
\beta \sim Normal(0,10) \\
\sigma \sim Uniform(0,50)
\end{aligned}
$$
The likelihood is Gaussian; the mean is dependent on finger length.

The prior for $\alpha$ is Gaussian and centred on the overall mean for criminal heights (166) but with a huge standard deviation that will effectively allow the parameter to settle over an appropriate value for $\alpha$ - conceptually the mean height of criminals when finger length is 0; although in practice this wouldn't happen.

The prior for $\beta$ is conservative; as a Gaussian centred on 0 it implies that we are giving equal weight to the possibility of a positive or negative parameter values for $\beta$, either a positive or negative slope; however we could expect $\beta$ to be positive. As a $\beta$ of 0 suggests no relationship this is a conservative prior assumption. The large standard deviation is again permissive to allow the parameter to move easily to a meaningful value. As this model uses a lot of data the impact of this conservative prior is weak, but with less data a more informative prior may be more useful.

Finally the prior for $\sigma$ is flat with a large range, again allowing the model flexibility to move to achieve a good fit.

The models can be translated into code.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python eval = FALSE}
criminals_model = pm.Model()

with criminals_model:
    # Priors
    alpha = pm.Normal('alpha', mu = 166, sd = 100)
    beta = pm.Normal('beta', mu = 0, sd = 10)
    sigma = pm.Uniform('sigma', lower = 0, upper = 50)
    
    # Linear Model
    mu = alpha + beta * criminals['finger_length']
    
    # Likelihood
    height = pm.Normal('height', mu = mu, sd = sigma, observed = criminals['height'])
```
 
 
Note - this will take a very long time to run on ONS Machines. This is due to the package m2w64-toolchain not being available and the sample size being large (3000 rows) 

A version of the posterior is available as a pickle file in the cell below. It is recommended you load that rather than try and calculate this yourself.

```{python eval = FALSE}
# Caution - will take hours to run, load pickle in cell below.
posterior = pm.sample(model=criminals_model, tune = 4500)

```

Load the posterior via pickle if you are unable to run the sampler (likely)
```{python eval = FALSE}
import pickle     
with open('../data/model.pickle', 'rb') as buff:
    data = pickle.load(buff)
criminals_model = data['model']
posterior = data['trace']
```

### **R**  {.unnumbered .toc-ignore}

Here the function `stan_glm()` from the `rstanarm` package is used. This is creating a generalised linear model.

While in the Python model we specified the priors, here the defaults work well.


```{r}
criminals_model <- rstanarm::stan_glm(formula = "height ~ finger_length",
                   data = criminals)
```

## {.unlisted .unnumbered .toc-ignore}

Now the model is created it can be used to explore the relationship between finger length and height.
We can find the *maximum a posteriori* values for $\alpha$ and $\beta$ and plot the line within the data. 
This is effectively the mean line; the most plausible line drawn from the infinite possible lines that make up the posterior distribution of this model. This is very similar to the standard least squares fit.


## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

Find the MAP
```{python eval = FALSE}
criminals_map = pm.find_MAP(model = criminals_model)
print(f"model alpha: {criminals_map['alpha']}, model beta: {criminals_map['beta']}")
```
 
```{python echo = FALSE}
print("model alpha: 76.70927324810782, model beta: 7.758674279162565")
```

Plot

```{python eval = FALSE}
f, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5))

# Maximum a posteriori
xs = np.linspace(criminals['finger_length'].min(),criminals['finger_length'].max(),2)
yhat_bayes = criminals_map['alpha'] + criminals_map['beta'] * xs
ax1.scatter(criminals['finger_length'], criminals['height'], marker='.', color = '0.45', alpha = 0.25)
ax1.plot(xs, yhat_bayes, color = 'crimson')
ax1.set_title("Maximum a posteriori line")
ax1.text(9.5, 194, r"$\alpha$: " + str(criminals_map['alpha'].round(2)), fontsize = 12)
ax1.text(9.5, 190, r"$\beta$: " + str(criminals_map['beta'].round(2)), fontsize = 12)
ax1.set_ylabel('Height (cm)')
ax1.set_xlabel('Finger Length (cm)')

# Least squares
params = np.polyfit(criminals['finger_length'], criminals['height'], deg = 1)

yhat_ols = params[1] + params[0] * xs
ax2.scatter(criminals['finger_length'], criminals['height'], marker='.', color = '0.45', alpha = 0.25)
ax2.plot(xs, yhat_ols, color = 'dodgerblue')
ax2.set_title("Least squares line")
ax2.text(9.5, 194, r"$\alpha$: " + str(params[1].round(2)), fontsize = 12)
ax2.text(9.5, 190, r"$\beta$: " + str(params[0].round(2)), fontsize = 12)
ax2.set_ylabel('Height (cm)')
ax2.set_xlabel('Finger Length (cm)');
plt.show()
```


```{python echo = FALSE}
'''
f, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5));

# Maximum a posteriori
xs = np.linspace(criminals['finger_length'].min(),criminals['finger_length'].max(),2);
yhat_bayes = 76.70927324810782 + 7.758674279162565 * xs  # alpha 76.70927324810782, model beta: 7.758674279162565
ax1.scatter(criminals['finger_length'], criminals['height'], marker='.', color = '0.45', alpha = 0.25);
ax1.plot(xs, yhat_bayes, color = 'crimson');
ax1.set_title("Maximum a posteriori line");
ax1.text(9.5, 194, r"$\alpha$: " + str(76.71), fontsize = 12);
ax1.text(9.5, 190, r"$\beta$: " + str(7.76), fontsize = 12);
ax1.set_ylabel('Height (cm)');
ax1.set_xlabel('Finger Length (cm)');

# Least squares
params = np.polyfit(criminals['finger_length'], criminals['height'], deg = 1);

yhat_ols = params[1] + params[0] * xs
ax2.scatter(criminals['finger_length'], criminals['height'], marker='.', color = '0.45', alpha = 0.25);
ax2.plot(xs, yhat_ols, color = 'dodgerblue');
ax2.set_title("Least squares line");
ax2.text(9.5, 194, r"$\alpha$: " + str(params[1].round(2)), fontsize = 12);
ax2.text(9.5, 190, r"$\beta$: " + str(params[0].round(2)), fontsize = 12);
ax2.set_ylabel('Height (cm)');
ax2.set_xlabel('Finger Length (cm)');
plt.show();;

# The excess ; are for suppression of lines in the HTML output.
'''
```




```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("python_chart_images/map_posterior.png"),
               alt = 'Learning Academy, Analysis Function and Data Science Campus Logos', 
               align = "centre")
```



### **R**  {.unnumbered .toc-ignore}
Find the MAP
```{r}
criminals_map <- bayestestR::map_estimate(criminals_model)
```

Plot

```{r, warning= FALSE}

# Maximum A Posteriori line
xs <- c(min(criminals$finger_length), max(criminals$finger_length))
yhat_bayes <- criminals_map$MAP_Estimate[1] + criminals_map$MAP_Estimate[2] * xs
yhat_bayes

# Plot
plot_map <- ggplot2::ggplot() +
  geom_point(aes(y = height, x = finger_length), data = criminals, alpha = 0.25) +
  geom_line(aes (x =xs,  y = yhat_bayes), color = "red") +
  labs(title = "Maximum a posteriori line") +
  annotate("text", x = 10, y = 190, label = expression(paste(alpha, "= 76.67")) , parse = TRUE, hjust = 0) +
  annotate("text", x = 10, y = 187, label = expression(paste(beta, "= 7.76")) , parse = TRUE, hjust = 0)

# OLS
  
ols_criminals <- lm(formula = "height ~ finger_length", data = criminals)

yhat_ols <- ols_criminals$coefficients[1] + ols_criminals$coefficients[2] * xs 

# Plot
plot_ols <- ggplot2::ggplot() +
  geom_point(aes(y = height, x = finger_length),data = criminals, alpha = 0.25) +
  geom_line(aes(x = xs, y = yhat_ols), color = "blue") +
  labs(title = "Least squares line") +
  annotate("text", x = 10, y = 190, label = expression(paste(alpha, "= 76.65")) , parse = TRUE, hjust = 0) +
  annotate("text", x = 10, y = 187, label = expression(paste(beta, "= 7.76")) , parse = TRUE, hjust = 0)


plot_map + plot_ols  # This requires patchwork package to place plots side by side

```

## {.unlisted .unnumbered .toc-ignore}

However the maximum a posteriori line doesn't show much of a sense of uncertainty or the range of plausible values that $\alpha$ or $\beta$ could take. As this is one of the reasons for choosing Bayesian modelling we will now explore this further.

We can inspect the traceplot and the summary for more information.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

Note that these cells may take a while (at least several minutes) to run, even with loading in data this is quite a slow process on ONS machines.

Traceplot
```{python eval = FALSE}
pm.traceplot(posterior);
```

<!--- again faked as an image here -->

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("../images/criminals_pymc3_trace.png "),
               alt = 'Trace Plot - Criminals', 
               align = "centre")
```


Summary

```{python eval = FALSE}
pm.summary(posterior)
```


|   .   | mean   | sd    | hdi_3% | hdi_97% | mcse_mean | mcse_sd | ess_bulk | ess_tail | r_hat |
|-------|--------|-------|--------|---------|-----------|---------|----------|----------|-------|
| alpha | 77.799 | 1.924 | 74.083 | 81.122  | 0.87      | 0.659   | 5.0      | 69.0     | 1.32  |
| beta  | 7.665  | 0.167 | 7.384  | 7.992   | 0.075     | 0.057   | 5.0      | 64.0     | 1.32  |
| sigma | 4.896  | 0.052 | 4.814  | 4.996   | 0.012     | 0.009   | 22.0     | 109.0    | 1.06  |



### **R**  {.unnumbered .toc-ignore}

```{r}
bayesplot::mcmc_trace(criminals_model)
```


```{r}
summary(criminals_model)
```

## {.unlisted .unnumbered .toc-ignore}

## Uncertainty

The posterior effectively contains a lot of lines given the $\alpha$ and $\beta$ estimates. The MAP is the most plausible of these lines, but the variation in the sample of lines gives a sense of the uncertainty in the estimate of the "mean" line.

This can be seen in the chart below that plots some examples of lines in the posterior.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

<!-- Loading in the posterior as data here because it's just so much easier -->

```{python echo = FALSE}
posterior = pd.read_csv("data_for_RMD/criminal_posterior.csv")

# Convert back to np arrays
alpha = np.array(posterior["alpha"])
beta = np.array(posterior["beta"])
sigma = np.array(posterior["sigma"])
```

<!-- code resumes -->

```{python eval = FALSE}
# Plots
f, (ax1, ax2, ax3) = plt.subplots(1,3, figsize = (16, 5), sharex = True, sharey = True)

# x values for lines
xs = np.array([criminals['finger_length'].min(), criminals['finger_length'].max()]).reshape((-1,1))

# ax1 - ten random lines
rand_10 = np.random.randint(0,1000,10)
ten_lines = posterior[alpha][rand_10] + posterior[beta][rand_10] * xs
ax1.plot(xs, ten_lines, color = '0.4', alpha = 0.33)
ax1.scatter(criminals['finger_length'], criminals['height'], marker='.', color = '0.75', alpha = 0.25)
ax1.set_ylabel('Height (cm)')
ax1.set_xlabel('Finger Length (cm)')
ax1.set_title("10 Lines from the Posterior")

# ax2 - fifty random lines
rand_50 = np.random.randint(0,1000,50)
fifty_lines = posterior[alpha][rand_50] + posterior[beta][rand_50] * xs
ax2.plot(xs, fifty_lines, color = '0.4', alpha = 0.2)
ax2.scatter(criminals['finger_length'], criminals['height'], marker='.', color = '0.75', alpha = 0.25)
ax2.set_xlabel('Finger Length (cm)')
ax2.set_title("50 Lines from the Posterior")

# ax2 - five hundred random lines
rand_500 = np.random.randint(0,1000,500)
fivehundred_lines = posterior[alpha][rand_500] + posterior[beta][rand_500] * xs
ax3.plot(xs, fivehundred_lines, color = '0.4', alpha = 0.1)
ax3.scatter(criminals['finger_length'], criminals['height'], marker='.', color = '0.75', alpha = 0.25)
ax3.set_xlabel('Finger Length (cm)')
ax3.set_title("500 Lines from the Posterior");
plt.show()
```

<!--
```{python echo = FALSE}
# Plots
f, (ax1, ax2, ax3) = plt.subplots(1,3, figsize = (16, 5), sharex = True, sharey = True);

# x values for lines
xs = np.array([criminals['finger_length'].min(), criminals['finger_length'].max()]).reshape((-1,1))
# ax1 - ten random lines
rand_10 = np.random.randint(0,1000,10)
ten_lines = alpha[rand_10] + beta[rand_10] * xs


ax1.plot(xs, ten_lines, color = '0.4', alpha = 0.33);
ax1.scatter(criminals['finger_length'], criminals['height'], marker='.', color = '0.75', alpha = 0.25);
ax1.set_ylabel('Height (cm)');
ax1.set_xlabel('Finger Length (cm)');
ax1.set_title("10 Lines from the Posterior");

# ax2 - fifty random lines
rand_50 = np.random.randint(0,1000,50);
fifty_lines = alpha[rand_50] + beta[rand_50] * xs
ax2.plot(xs, fifty_lines, color = '0.4', alpha = 0.2);
ax2.scatter(criminals['finger_length'], criminals['height'], marker='.', color = '0.75', alpha = 0.25);
ax2.set_xlabel('Finger Length (cm)');
ax2.set_title("50 Lines from the Posterior");

# ax2 - five hundred random lines
rand_500 = np.random.randint(0,1000,500);
fivehundred_lines = alpha[rand_500] + beta[rand_500] * xs
ax3.plot(xs, fivehundred_lines, color = '0.4', alpha = 0.1);
ax3.scatter(criminals['finger_length'], criminals['height'], marker='.', color = '0.75', alpha = 0.25);
ax3.set_xlabel('Finger Length (cm)');
ax3.set_title("500 Lines from the Posterior");
plt.show();
```
-->
```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("python_chart_images/post_lines.png"),
               alt = 'Learning Academy, Analysis Function and Data Science Campus Logos', 
               align = "centre",
               width = 700)
```



### **R**  {.unnumbered .toc-ignore}



```{r}
# This may take about a minute to run.
ten_lines <- criminals %>% 
  tidybayes::add_fitted_draws(criminals_model, n = 10) %>%  # Selects only n draws from the posterior
  ggplot(aes(x = finger_length, y= height)) + 
  tidybayes::stat_lineribbon(aes(y = .value), .width = seq(0, 1, 0.1), alpha = 1/4, color = "red") +
  geom_point(data = criminals)+
  labs(title = "10 Lines from the Posterior")+
  scale_fill_brewer(guide = "none")

fifty_lines <- criminals %>% 
  tidybayes::add_fitted_draws(criminals_model, n = 50) %>% 
  ggplot(aes(x = finger_length, y= height)) + 
  tidybayes::stat_lineribbon(aes(y = .value), .width = seq(0, 1, 0.1), alpha = 1/4, color = "red") +
  geom_point(data = criminals) +
  labs(title = "50 Lines from the Posterior") +
  scale_fill_brewer(guide = "none")

five_hundred_lines <- criminals %>% 
  tidybayes::add_fitted_draws(criminals_model, n = 500) %>% 
  ggplot(aes(x = finger_length, y= height)) + 
  tidybayes::stat_lineribbon(aes(y = .value), .width = seq(0, 1, 0.1), alpha = 1/4, color = "red") +
  geom_point(data = criminals) +
  labs(title = "500 Lines from the Posterior") +
  scale_fill_brewer(guide = "none") 


ten_lines + fifty_lines + five_hundred_lines # This requires patchwork package to place plots side by side

```


## {.unlisted .unnumbered .toc-ignore}

Plotting these lines demonstrated the variation in estimates for the $\alpha$ and $\beta$ parameters.

## Credible Intervals

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

Rather than plotting sampled lines in reality a Bayesian credible interval would be used. Before doing this it can be helpful to look at the distribution of mean estimates for given finger length.


```{python eval = FALSE}
finger_length = 10.5 # cm

# means from posterior
mean_at_10_5 = posterior[alpha] + posterior[beta] * finger_length

# Plot the density curve for the posterior means.
f, ax = plt.subplots(figsize = (6,5))

xs = np.linspace(mean_at_10_5.min() - 1, mean_at_10_5.max() + 1, 100)
densities = gaussian_kde(mean_at_10_5)(xs)
ax.plot(xs, densities)
ax.set_xlabel("Height (cm)")
ax.set_ylabel("Density")
ax.set_title("Posterior Mean Height at finger length = 10.5cm")
plt.show();
```

```{python echo = FALSE}
finger_length = 10.5 # cm

mean_at_10_5 = alpha + beta * finger_length
```
<!--
```{python eval = FALSE}
# Plot the density curve for the posterior means.
f, ax = plt.subplots(figsize = (6,5));

xs = np.linspace(mean_at_10_5.min() - 1, mean_at_10_5.max() + 1, 100);
densities = gaussian_kde(mean_at_10_5)(xs);
ax.plot(xs, densities);
ax.set_xlabel("Height (cm)");
ax.set_ylabel("Density");
ax.set_title("Posterior Mean Height at finger length = 10.5cm");
plt.show();;

# Excessive semi colon use to suppress output in HTML file.

```
-->

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("python_chart_images/posterior_finger_length"),
               alt = 'Learning Academy, Analysis Function and Data Science Campus Logos', 
               align = "centre",
               width = 700)
```


This shows the approximation of the posterior distribution of mean height of criminals when their finger length is 10.5cm. This gives the relative plausibility of different values for mean height.

We can also compute the highest density interval for this distribution

```{python}
# hdi for finger length = 10.5
pm.hdi(mean_at_10_5)
```

This uncertainty around the mean line can be expressed by extending the process to the full domain of the data.

```{python eval = FALSE}
finger_lengths = np.arange(criminals['finger_length'].min(), criminals['finger_length'].max()+0.5, 0.5)
mu_predictions = np.array([posterior[alpha] + posterior[beta] * fl for fl in finger_lengths])
mu_mean = mu_predictions.mean(1)
mu_hdi = pm.hdi(mu_predictions.T)
```

```{python echo = FALSE}
finger_lengths = np.arange(criminals['finger_length'].min(), criminals['finger_length'].max()+0.5, 0.5 )
mu_predictions = np.array([alpha + beta * fl for fl in finger_lengths])
mu_mean = mu_predictions.mean(1)
mu_hdi = pm.hdi(mu_predictions.T)
```

<!--
```{python echo = FALSE}
f, ax = plt.subplots(figsize = (8,6))
ax.scatter(criminals['finger_length'], criminals['height'], marker='.', color = '0.75', alpha = 0.25)
ax.plot(finger_lengths, mu_mean, color = 'crimson')
ax.fill_between(finger_lengths, mu_hdi[:,0], mu_hdi[:,1], color = 'crimson', alpha = 0.33)
ax.set_ylabel('Height (cm)')
ax.set_xlabel('Finger Length (cm)');
plt.show();
```
-->
```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("python_chart_images/mu_lines.png"),
               alt = 'Learning Academy, Analysis Function and Data Science Campus Logos', 
               align = "centre",
               width = 700)
```


### **R**  {.unnumbered .toc-ignore}

Rather than plotting sampled lines in reality a Bayesian credible interval would be used. Before doing this it can be helpful to look at the distribution of mean estimates for given finger length.

```{r}

posterior <- as.data.frame(criminals_model)
names(posterior)[1] <- "intercept"


finger_length <- 10.5 #cm

# means from posterior

mean_at_10_5 <- posterior$intercept + posterior$finger_length * finger_length

ggplot2::ggplot() +
  stat_density(aes(mean_at_10_5)) + 
  labs(title = "Posterior Mean Height at finger length = 10.5cm", x = "Height (cm)") 

```

This shows the approximation of the posterior distribution of mean height of criminals when their finger length is 10.5cm. This gives the relative plausibility of different values for mean height.

We can also compute the highest density interval for this distribution

 
```{r}
HDInterval::hdi(mean_at_10_5)
```

## {.unlisted .unnumbered .toc-ignore}

## Prediction Interval

The interval above gives some information about the uncertainty in average height, but the posterior estimates of $\sigma$ to do this. Using a likelihood function new data can be generated on estimates of $\alpha$, $\beta$ and $\sigma$. A HDI interval can then be created from these data points.

## {.tabset .tabset-fade .unnumbered .unlisted .toc-ignore} 

### **Python**  {.unnumbered .toc-ignore}

```{python eval = FALSE}
finger_lengths1 = np.arange(criminals['finger_length'].min(), criminals['finger_length'].max()+0.1, 0.1)

# Generate heights from the posterior distribution
post_samples = []
for _ in range(1000):
    i = np.random.randint(len(posterior))
    mu_pred = posterior[alpha][i] + posterior[beta][i] * finger_lengths1
    post_samples.append(np.random.normal(mu_pred, posterior[sigma][i]))
post_samples = np.array(post_samples)

# get interval for generated heights
post_samples_hdi = pm.hdi(post_samples))
```

```{python echo = FALSE}
finger_lengths1 = np.arange(criminals['finger_length'].min(), criminals['finger_length'].max()+0.1, 0.1)

# Generate heights from the posterior distribution
post_samples = []
for _ in range(1000):
    i = np.random.randint(len(posterior))
    mu_pred = alpha[i] + beta[i] * finger_lengths1
    post_samples.append(np.random.normal(mu_pred, sigma[i]))
post_samples = np.array(post_samples)

# get interval for generated heights
post_samples_hdi = pm.hdi(post_samples)

```

```{python eval = FALSE}
f, ax = plt.subplots(figsize = (8,6))
ax.scatter(criminals['finger_length'], criminals['height'], marker='.', color = '0.75', alpha = 0.25)
ax.plot(finger_lengths, mu_mean, color = 'crimson')
ax.fill_between(finger_lengths, mu_hdi[:,0], mu_hdi[:,1], color = 'crimson', alpha = 0.33)
ax.fill_between(finger_lengths1, post_samples_hdi[:,0], post_samples_hdi[:,1], color = 'orange', alpha = 0.1)
ax.set_ylabel('Height (cm)')
ax.set_xlabel('Finger Length (cm)');
plt.show();
```


```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("../images/posterior_inference.png"),
               alt = 'Posterior Inference', 
               align = "centre",
               width = 700)
```


### **R**  {.unnumbered .toc-ignore}

```{r}
prediction_interval <- criminals %>% 
  tidybayes::add_predicted_draws(criminals_model) %>% 
  ggplot(aes(x = finger_length, y= height)) + 
  tidybayes::stat_lineribbon(aes(y = .prediction), .width = seq(0, 0.85, 0.1) , color = "red", fill = "orange", alpha = 1/20) +
  geom_point(data = criminals) +
  scale_fill_brewer(guide = "none")

prediction_interval
```

## {.unlisted .unnumbered .toc-ignore}

The plot shows an 89% prediction interval for height as a function of finger length (orange). The red line is the MAP line and the narrow shaded area around the line is the uncertainty of the MAP line.

Both shaded areas are plausible regions, the narrow shaded area is the distribution of the mean given by the linear model; and the wide shaded area is the region within which the model expects to find 89% of the actual heights in the population.

# Summary

The topic of Bayesian Data Analysis is much much larger than can be covered within this course. For example this is a simple linear model - this could be expanded to a multivariate linear model if more explanatory values became available. You may like to think about how the model would change, and what that would mean for the inclusion of priors.

There is a list of references at the bottom of this course; but a strong recommendation throughout the research for this course has been McElreath R. 2016. **Statistical Rethinking: A Bayesian Course with Examples in R and Stan. CRC Press.** 


# References / Acknowledgements

The Analytical Function Learning Team for all of their help in getting all of the elements of this course to work so seamlessly.

Laurie Baker from the Data Science Campus - the segment on Bayesian Statistics as part of the Statistics for Data Science Python course has been a large influence on this course.

Pragya Paudyal, Aidan Metcalfe and James Cranston for their reviews and feedback.

["Introduction to Bayesian Data Analysis" by Rasmus Bååth](https://www.youtube.com/watch?v=3OJEae7Qb_o)

["Introduction to Bayesian Data Analysis" from "Analytical Paleobiology", Peter D Smits, 2019-05-23](https://psmits.github.io/paleo_book/introduction-to-bayesian-data-analysis.html)

["Alan Turing and Enigmatic Statistics", Kanti V. Mardia and S. Barry Cooper, 2012-12](http://www.mathcomp.leeds.ac.uk/turing2012/Images/Turing_Statistics.pdf)

["The signal and the noise: Nate Silver, Bayesian methods and higher education" Graeme Wise 2019-10-14 (PDF)](https://wonkhe.com/blogs/the-signal-and-the-noise-nate-silver-bayesian-methods-and-higher-education/)

["What is Bayesian Analysis" STATA](https://www.stata.com/features/overview/bayesian-intro/#:~:text=Bayesian%20analysis%20is%20a%20statistical,between%2060%20and%2070%20inches%3F)

["Updating: A Set of Bayesian Notes" Jeffery B Arnold, N.D](https://jrnold.github.io/bayesian_notes/bayesian-computation.html)

["Bayesian vs. Frequentist A/B Testing: What’s the Difference?" Alex Birkett 2020-01-18](https://cxl.com/blog/bayesian-frequentist-ab-testing/#:~:text=%E2%80%9CThe%20difference%20is%20that%2C%20in,frequentist%20approach%2C%20they%20are%20fixed.&text=In%20the%20frequentist%20view%2C%20a,without%20being%20assigned%20a%20probability.)

["Plotting MCMC draws using the bayesplot package", Jonah Gabry, 2021-06-13](https://cran.r-project.org/web/packages/bayesplot/vignettes/plotting-mcmc-draws.html )

["Extracting and visualizing tidy draws from rstanarm models" Matthew Kay, 2020-10-31 ](http://mjskay.github.io/tidybayes/articles/tidy-rstanarm.html )

[]()

